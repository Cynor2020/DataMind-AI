required_fields = ['column', 'fill_method', 'method', 'value', 'changes', 'type','action','outlier_method','fix_datatypes','standardize_to','rule','list_columns','list_row']
column 
fill_method  = "remove", "mean", "median", "mode", "custom"
method = "std_dev", "iqr", "z_score" , "none", "remove"
value = 
changes = "", "fix", "revert"
type = "none", "row", "column"
action = 
outlier_method = 
fix_datatypes = 
standardize_to = 
rule = 
list_columns = 
list_row = 
target_type  = "int", "float", "str", "bool", "datetime"

action = form_data['action']
column = form_data['column']
fill_method = form_data['fill_method']
method = form_data['method']
outlier_method = form_data['outlier_method']
value = form_data['value']
changes = form_data['changes']
typee = form_data['type']
target_type = form_data['target_type']
standardize_to= form_data['standardize_to']
rule = form_data['rule']
list_columns = form_data['list_columns']
list_row = form_data['list_row']
























        required_fields = ['column', 'fill_method', 'method', 'value', 'changes', 'type','action','outlier_method','fix_datatypes','standardize_to','rule','list_columns','list_row']
        for field in required_fields:
            if field not in form_data:
                return jsonify({'message': f'Missing required field: {field}'}), 400
        # result_df = df.to_dict('records')    
        # result_collection.insert_one({
        #     'file_id': ObjectId(file_id),
        #     'email': email,
        #     'result_df':result_df,
        #     'created_at': datetime.datetime.utcnow()
        # })
        action = form_data['action']
        column = form_data['column']
        fill_method = form_data['fill_method']
        method = form_data['method']
        outlier_method = form_data['outlier_method']
        value = form_data['value']
        changes = form_data['changes']
        typee = form_data['type']
        target_type = form_data['target_type']
        standardize_to= form_data['standardize_to']
        rule = form_data['rule']
        list_columns = form_data['list_columns']
        list_row = form_data['list_row']
        # Validate column
        if column not in df.columns:
            return jsonify({'message': f'Column {column} not found in CSV'}), 400

        # Call model.missing_handler
        # if action == "handel_missing_values":
        try:
            result = model.missing_handler(df,column=column,Fill_Method=fill_method,value=value,method=method,type=typee,changes=changes)
            # result_df =  result.get('flagged_df')
            # result_collection.update_one({"_id": file_id}, {"$set": {"result_df": result_df.to_dict('records')}})
        except Exception as e:
            return jsonify({'message': f'Error in analysis: {str(e)}'}), 500
        if action == 'remove_duplicates':
            try:
                result = model.remove_duplicates(df,column=column,typee=typee) 
            except Exception as e:
                return jsonify({'message': f'Error in analysis: {str(e)}'}), 500 
                        
        if action == 'outlier':
            try:
                result = model.out_lier(df,column=column,fill_method=fill_method,method=outlier_method) 
            except Exception as e:
                return jsonify({'message': f'Error in analysis: {str(e)}'}), 500 
        if action == 'fix_datatypes':
            try:
                result = model.fix_datatypes(df,column=column,target_type = target_type) 
            except Exception as e:
                return jsonify({'message': f'Error in analysis: {str(e)}'}), 500 
        if action == 'correct_data':
                    try:
                        result = model.correct_data(df,column=column,standardize_to= standardize_to) 
                    except Exception as e:
                        return jsonify({'message': f'Error in analysis: {str(e)}'}), 500 
        if action == 'standardize_data':
             try:
                result = model.standardize_data(df,list_columns=list_columns,rule=rule) 
             except Exception as e:
                return jsonify({'message': f'Error in analysis: {str(e)}'}), 500 
        if action == 'remove_data':
             try:
                result = model.remove_data(df,column=column,changes=changes,list_columns=list_columns,list_row=list_row) 
             except Exception as e:
                return jsonify({'message': f'Error in analysis: {str(e)}'}), 500 
             

             
        # result_df =  result.get('flagged_df')
        # result_df = result_df.to_dict('records')









        @app.route('/clean_data/<file_id>', methods=['POST', 'OPTIONS'])
def clean_data(file_id):
    if request.method == 'OPTIONS':
        return jsonify({}), 200

    if request.method != 'POST':
        return jsonify({'message': f'Method {request.method} not allowed'}), 405

    try:
        # Token validation
        token = request.headers.get('Authorization')
        if not token:
            return jsonify({'message': 'Token is missing'}), 401

        try:
            token = token.replace('Bearer ', '').strip()
            data = jwt.decode(token, SECRET_KEY, algorithms=['HS256'])
            email = data['email']
        except jwt.InvalidTokenError as e:
            return jsonify({'message': 'Invalid token'}), 401

        # Fetch file from MongoDB
        try:
            file_doc = files_collection.find_one({'_id': ObjectId(file_id), 'email': email})
            if not file_doc:
                return jsonify({'message': 'File not found or you do not have access'}), 404
        except Exception as e:
            return jsonify({'message': 'Invalid file ID format'}), 400

        # Check file type
        if file_doc['filetype'] != 'csv':
            return jsonify({'message': 'Only CSV files can be analyzed'}), 400

        # Decode CSV data
        try:
            csv_data = file_doc['data'].decode('utf-8') if isinstance(file_doc['data'], bytes) else file_doc['data']
            if not isinstance(csv_data, str):
                return jsonify({'message': 'Invalid data format: Expected raw CSV data'}), 400
        except Exception as e:
            return jsonify({'message': 'Error decoding CSV data'}), 400

        # Read CSV into DataFrame
        try:
            df = pd.read_csv(StringIO(csv_data))
        except Exception as e:
            return jsonify({'message': f'Error reading CSV: {str(e)}'}), 400

        # Get form data
        form_data = request.json
        if not form_data:
            return jsonify({'message': 'Form data is missing'}), 400

        required_fields = ['column', 'fill_method', 'method', 'value', 'changes', 'type','action','outlier_method','fix_datatypes','standardize_to','rule','list_columns','list_row']
        for field in required_fields:
            if field not in form_data:
                return jsonify({'message': f'Missing required field: {field}'}), 400
        action = form_data['action']
        column = form_data['column']
        fill_method = form_data['fill_method']
        method = form_data['method']
        outlier_method = form_data['outlier_method']
        value = form_data['value']
        changes = form_data['changes']
        typee = form_data['type']
        target_type = form_data['target_type']
        standardize_to= form_data['standardize_to']
        rule = form_data['rule']
        list_columns = form_data['list_columns']
        list_row = form_data['list_row']
        # Validate column
        if column not in df.columns:
            return jsonify({'message': f'Column {column} not found in CSV'}), 400

        # Call model.missing_handler
        if action == "handel_missing_values":
            try:
                result = model.missing_handler(df,column=column,Fill_Method=fill_method,value=value,method=method,type=typee,changes=changes)
            except Exception as e:
                return jsonify({'message': f'Error in analysis: {str(e)}'}), 500
        if action == 'remove_duplicates':
            try:
                result = model.remove_duplicates(df,column=column,typee=typee) 
            except Exception as e:
                return jsonify({'message': f'Error in analysis: {str(e)}'}), 500 
                        
        if action == 'outlier':
            try:
                result = model.out_lier(df,column=column,fill_method=fill_method,method=outlier_method) 
            except Exception as e:
                return jsonify({'message': f'Error in analysis: {str(e)}'}), 500 
        if action == 'fix_datatypes':
            try:
                result = model.fix_datatypes(df,column=column,target_type = target_type) 
            except Exception as e:
                return jsonify({'message': f'Error in analysis: {str(e)}'}), 500 
        if action == 'correct_data':
                    try:
                        result = model.correct_data(df,column=column,standardize_to= standardize_to) 
                    except Exception as e:
                        return jsonify({'message': f'Error in analysis: {str(e)}'}), 500 
        if action == 'standardize_data':
             try:
                result = model.standardize_data(df,list_columns=list_columns,rule=rule) 
             except Exception as e:
                return jsonify({'message': f'Error in analysis: {str(e)}'}), 500 
        if action == 'remove_data':
             try:
                result = model.remove_data(df,column=column,changes=changes,list_columns=list_columns,list_row=list_row) 
             except Exception as e:
                return jsonify({'message': f'Error in analysis: {str(e)}'}), 500 
             

             
        result_df =  result.get('flagged_df')
        result_df = result_df.to_dict('records')
        # Build result dictionary
        result_dict = {
            'status': result.get('status', 'unknown'),
            'affected_rows': int(result.get('affected_rows', 0)) if result.get('affected_rows') else 0,
            'affected_columns': result.get('affected_columns', 0),
            'removed_row': result.get('removed_row', 'none'),
            'removed_column': result.get('removed_column', 'none'),
            'form_data': form_data
            
            
        }
        
        # Insert analysis result into analysis_results collection
        analysis_results_collection.insert_one({
            'file_id': ObjectId(file_id),
            'email': email,
            'analysis_result': result_dict,
            'result_df':result_df,
            'created_at': datetime.datetime.utcnow()
        })
        return jsonify(
           result_dict
            
        ), 200

    except Exception as e:
        return jsonify({'message': f'Error: {str(e)}'}), 500
    


app.route('/clean_data/<file_id>', methods=['POST', 'OPTIONS'])
def clean_data(file_id):
    if request.method == 'OPTIONS':
        return jsonify({}), 200

    if request.method != 'POST':
        return jsonify({'message': f'Method {request.method} not allowed'}), 405

    try:
        # Token validation
        token = request.headers.get('Authorization')
        if not token:
            return jsonify({'message': 'Token is missing'}), 401

        try:
            token = token.replace('Bearer ', '').strip()
            data = jwt.decode(token, SECRET_KEY, algorithms=['HS256'])
            email = data['email']
        except jwt.InvalidTokenError as e:
            return jsonify({'message': 'Invalid token'}), 401

        # Fetch file from MongoDB
        try:
            file_doc = files_collection.find_one({'_id': ObjectId(file_id), 'email': email})
            if not file_doc:
                return jsonify({'message': 'File not found or you do not have access'}), 404
        except Exception as e:
            return jsonify({'message': 'Invalid file ID format'}), 400

        # Check file type
        if file_doc['filetype'] != 'csv':
            return jsonify({'message': 'Only CSV files can be analyzed'}), 400

        # Decode CSV data
        try:
            csv_data = file_doc['data'].decode('utf-8') if isinstance(file_doc['data'], bytes) else file_doc['data']
            if not isinstance(csv_data, str):
                return jsonify({'message': 'Invalid data format: Expected raw CSV data'}), 400
        except Exception as e:
            return jsonify({'message': 'Error decoding CSV data'}), 400

        # Read CSV into DataFrame
        try:
            df = pd.read_csv(StringIO(csv_data))
        except Exception as e:
            return jsonify({'message': f'Error reading CSV: {str(e)}'}), 400

        # Get form data
        form_data = request.json
        if not form_data:
            return jsonify({'message': 'Form data is missing'}), 400

        required_fields = ['column', 'fill_method', 'method', 'value', 'changes', 'type','action','outlier_method','fix_datatypes','standardize_to','rule','list_columns','list_row']
        for field in required_fields:
            if field not in form_data:
                return jsonify({'message': f'Missing required field: {field}'}), 400
        action = form_data['action']
        column = form_data['column']
        fill_method = form_data['fill_method']
        method = form_data['method']
        outlier_method = form_data['outlier_method']
        value = form_data['value']
        changes = form_data['changes']
        typee = form_data['type']
        target_type = form_data['target_type']
        standardize_to= form_data['standardize_to']
        rule = form_data['rule']
        list_columns = form_data['list_columns']
        list_row = form_data['list_row']
        # Validate column
        if column not in df.columns:
            return jsonify({'message': f'Column {column} not found in CSV'}), 400

        # Call model.missing_handler
        if action == "handel_missing_values":
            try:
                result = model.missing_handler(df,column=column,Fill_Method=fill_method,value=value,method=method,type=typee,changes=changes)
            except Exception as e:
                return jsonify({'message': f'Error in analysis: {str(e)}'}), 500
        if action == 'remove_duplicates':
            try:
                result = model.remove_duplicates(df,column=column,typee=typee) 
            except Exception as e:
                return jsonify({'message': f'Error in analysis: {str(e)}'}), 500 
                        
        if action == 'outlier':
            try:
                result = model.out_lier(df,column=column,fill_method=fill_method,method=outlier_method) 
            except Exception as e:
                return jsonify({'message': f'Error in analysis: {str(e)}'}), 500 
        if action == 'fix_datatypes':
            try:
                result = model.fix_datatypes(df,column=column,target_type = target_type) 
            except Exception as e:
                return jsonify({'message': f'Error in analysis: {str(e)}'}), 500 
        if action == 'correct_data':
                    try:
                        result = model.correct_data(df,column=column,standardize_to= standardize_to) 
                    except Exception as e:
                        return jsonify({'message': f'Error in analysis: {str(e)}'}), 500 
        if action == 'standardize_data':
             try:
                result = model.standardize_data(df,list_columns=list_columns,rule=rule) 
             except Exception as e:
                return jsonify({'message': f'Error in analysis: {str(e)}'}), 500 
        if action == 'remove_data':
             try:
                result = model.remove_data(df,column=column,changes=changes,list_columns=list_columns,list_row=list_row) 
             except Exception as e:
                return jsonify({'message': f'Error in analysis: {str(e)}'}), 500 
             

             
        result_df =  result.get('flagged_df')
        result_df = result_df.to_dict('records')
        # Build result dictionary
        result_dict = {
            'status': result.get('status', 'unknown'),
            'affected_rows': int(result.get('affected_rows', 0)) if result.get('affected_rows') else 0,
            'affected_columns': result.get('affected_columns', 0),
            'removed_row': result.get('removed_row', 'none'),
            'removed_column': result.get('removed_column', 'none'),
            'form_data': form_data
            
            
        }
        
        # Insert analysis result into analysis_results collection
        analysis_results_collection.insert_one({
            'file_id': ObjectId(file_id),
            'email': email,
            'analysis_result': result_dict,
            'result_df':result_df,
            'created_at': datetime.datetime.utcnow()
        })
        return jsonify(
           result_dict
            
        ), 200

    except Exception as e:
        return jsonify({'message': f'Error: {str(e)}'}), 500